---
title: "ADR: TaskDef は digest 固定"
---

**Status**: Accepted  
**Date**: 2025-10-21 JST  
**Owner**: Papyrus Invoice（ECS/Fargate + ECR）  
**Tags**: ECS, ECR, Deploy, Rollback, Reproducibility

## 背景 / Context

Papyrus Invoice では、ECS Fargate 上で動作するアプリケーションイメージを ECR に保持し、  
CI からデプロイを実行している。

イメージのタグ運用は次のような前提がある。

- ECR には、主に `v*.*.*` 形式のタグ（例: `v25.10.31`）を付与して push する  
- タグ付き push は、リモートの `master` ブランチ更新時や、`v*.*.*` タグの push 時に行う
- 一方で、`latest` のような**可変タグにタスク定義を紐付けた場合**、次の問題が起こり得る
  - タグの指す中身が書き換わるため、同じ TaskDef を参照しても実体が変わる
  - ロールバック時に「以前の状態」が再現しづらい
  - SBOM や脆弱性スキャンを行う前提で見たとき、**どのイメージを検査したのか**を特定しづらい

デプロイフロー自体はシンプルで、

1. `master` ブランチ更新または `v*.*.*` タグの push
2. CI による ECR へのイメージ push
3. ECS タスク定義の更新
4. GitHub Actions から ECS Deploy ワークフローを手動実行

という流れになっており、この中で「TaskDef に何を指定するか（タグか digest か）」を決める必要があった。

## 決定 / Decision

Papyrus Invoice では、ECS タスク定義に記載するコンテナイメージを **digest 固定**とする。

- TaskDef の `image` には `image@sha256:……` 形式を用いる  
  （例: `<account>.dkr.ecr.<region>.amazonaws.com/papyrus@sha256:xxxx...`）
- ECR タグ（`v*.*.*` など）は、人間が識別しやすいラベルとしては残すが、  
  **実際の実行イメージの参照元は digest とする**
- `latest` はタスク定義には使用しない

ロールバック時は、次のいずれかの方法で対処する。

- CI で「以前のタグ」に紐付く digest を取得し、その digest を使って再デプロイする  
- あるいは ECS 側のタスク定義リビジョンから、「問題ない状態だったリビジョン」を選び直す

いずれの場合も、「どの digest のイメージで動かしていたか」が分かる前提で運用する。

## 代替案 / Alternatives

### 案A: `latest`／可変タグを TaskDef に直接指定する

- 内容  
  - `image: <ECR>/papyrus:latest` のように、可変タグを TaskDef に書き込む

- 不採用理由  
  - タグの付け替えで中身が変わるため、同じタスク定義が**別のイメージ**を指す可能性がある  
  - ロールバック時に「当時動いていたイメージ」を特定しづらく、再現性が低い  
  - SBOM や脆弱性スキャンの結果を「どのイメージに対するものか」紐付けにくい

### 案B: タグのみを運用し、digest は特に意識しない

- 内容  
  - `v25.10.31` のようなタグを TaskDef にそのまま指定し、digest 固定は行わない

- 不採用理由  
  - タグの再利用や上書きが起きた場合、過去の TaskDef が別の内容を指すリスクが残る  
  - 「タグ名は同じだが、中身だけビルドし直した」ような運用が混ざると、  
    ロールバックや監査の観点で追跡が難しくなる  
  - 将来的に SBOM / スキャン結果を積み上げる場合でも、digest 単位で管理した方が扱いやすい

### 案C: digest 固定はするが、タグを運用しない

- 内容  
  - タグを付けず、digest のみでイメージを判別する

- 不採用理由  
  - 人間が見る際に「どの変更に対応するビルドか」が分かりにくくなる  
  - CI やリリースノート上で、バージョン名とイメージを対応づける作業が面倒になる

## 影響 / Consequences

### 利点

1. **再現性とロールバックのしやすさが上がる**  
   - TaskDef が常に `image@sha256:…` を指すため、「このリビジョンはこのイメージ」と一意に対応づけられる。  
   - 不具合発生時には、以前の digest に戻すだけで「以前と同じ状態」を再現できる。

2. **将来の SBOM / 脆弱性管理と相性が良い**  
   - 1 digest = 1 イメージとして扱えるため、後から「どのライブラリ構成のイメージに対してスキャンしたか」を追いやすい。  
   - 現時点では SBOM / スキャンは未導入だが、digest 固定はその準備としても意味がある。

3. **`latest` 地雷を回避できる**  
   - 「気づかないうちに latest の中身が変わっていた」という典型的な事故パターンを避けられる。  
   - 可変タグを本番経路に使わない方針が明確になる。

### 注意点・トレードオフ

1. **digest を扱う手間が増える**  
   - 人間にとって digest は長く読みづらいが、これはタグとの併用でカバーする。  
   - CI 内で「タグ → digest」の解決処理が必要になる。

2. **実装側の整合性が前提になる**  
   - CI / デプロイフローが digest 前提で設計されていないと、  
     「タグで push しているのに TaskDef は digest を前提にしている」といった齟齬が生じる。  
   - ECR push、TaskDef 更新、デプロイの各ステップで前提を揃える必要がある。

3. **SBOM / スキャンがまだ運用に乗っていない**  
   - digest 固定は、将来のセキュリティ運用と相性が良い一方、  
     現時点では「恩恵の一部は将来受ける前提」になっている。

## 記録 / Decision Record

- **Date**: 2025-10-21 JST  
- **Owner**: Papyrus Invoice（ECS/Fargate + ECR）  
- **Scope**:  
  - Papyrus Invoice の ECS サービスで使用するタスク定義（本番相当 / 検証環境）  
  - ECR イメージ参照方法のポリシー  
- **例外**:  
  - 現時点で、digest 固定ルールの例外は設けない

## フォローアップ / Follow-ups

- **安全なタグ戦略の整理**  
  - タグは人間向けラベルと位置づけ、`v*.*.*` や `release-*` などの規則を整える。  
  - タグと digest を、コミットやチケットと紐付ける運用をドキュメント化する。

- **SBOM / 脆弱性スキャンとの連携**  
  - digest 単位で SBOM を生成し、スキャン結果とあわせて管理する構成を検討する。  
  - 「どの digest のイメージをいつ本番に出したか」を追えるラインを目標とする。

- **ロールバック手順の明文化**  
  - 「直前のデプロイを戻す場合」「過去の安定版に戻す場合」などパターン別に、  
    使用するタグ・digest・TaskDef リビジョンを明示した手順を整理する。