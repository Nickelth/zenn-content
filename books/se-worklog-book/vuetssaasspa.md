---
title: "製造現場向け業務効率化SaaSプラットフォーム 運用保守PJ"
---

## 製造現場向け業務効率化SaaS SPA

### 概要

#### ドメイン

製造現場向け業務効率化SaaSプラットフォーム  
（設備管理・図面管理・不良記録・日報管理・作業報告書 など）

#### 目的

紙や Excel ベースで分散していた設備・図面・不良・日報などの情報を、  
SaaS 上で一元管理し、現場からブラウザで登録・参照できるようにすること。

#### 構成

TypeScript ＋ Vue.js（SPA）＋ Node.js ＋ Nest.js（REST API）＋ Prisma ＋ Aurora（PostgreSQL）  
＋ ECS Fargate ＋ ECR ＋ CodePipeline / CodeCommit / CodeBuild ＋ S3 ＋ Docker Desktop

### 案件情報

期間：2024/08 〜 現在  

体制：PM 1名、PL 2名、SE 3〜4名からなる 4〜7名の受託開発チーム（時期により変動）。  

自分の役割：フロントエンド／バックエンド改修、および AWS 環境の運用保守を担当。

### 担当業務

- フロントエンド／バックエンドの改修（Vue.js／Nest.js／TypeScript）
- Nest.js の脆弱性対応（v10 → v11）に伴う依存パッケージ更新と破壊的変更点への対応（DI 構成、Decorator など）
- CI/CD パイプライン（CodeBuild／CodeDeploy／CodePipeline）の保守・改修  
  - `buildspec.yaml` の修正、Docker ビルドの最適化、Node.js 依存関係の整理
- 開発／本番 DB へのリモートポートフォワーディング用 PowerShell スクリプトの改修
- AWS 環境での運用・保守対応  
  - S3／CloudFront を用いた静的コンテンツ配信とアクセスログの確認  
  - CloudWatch Logs による ECS Fargate 上のコンテナログ監視  
  - Amazon Inspector のセキュリティ診断結果に基づく修正対応  
  - ECR イメージ管理と CodePipeline を用いた自動デプロイ運用  
  - Aurora 周辺での障害発生時の DB 復旧対応（EventBridge を含む関連サービス設定の確認・調整）  
  - タスク定義ファイル（`taskdef.json.tpl`）の更新

- その他業務  
  - 顧客データの復元・物理削除対応（S3／PostgreSQL）
  - Auth0 を利用した認証処理に関するパフォーマンス改善対応
  - レスポンシブ対応を含むフロントエンド UI 修正（CSS／Vue.js）

### 技術スタック

**言語・FW:** TypeScript, Vue.js, Nest.js, Prisma, CSS, PowerShell, PostgreSQL  

**インフラ:** AWS ECS Fargate, ECR, Aurora (PostgreSQL), S3, CodePipeline, CodeCommit, CodeBuild  

**ツール類:** VS Code, Docker Desktop, A5:SQL Mk-2, Git, WinMerge, Redmine

### Key ADR

#### ADR-01: Nest.js の脆弱性対応（v10 → v11）に伴う依存パッケージ更新と破壊的変更点への対応の実施判断

##### 背景

Amazon Inspector の脆弱性診断で、Nest.js アプリケーションが依存している npm パッケージに複数の脆弱性が検出された。  
これらを解消するには、Nest.js v11 系に準拠したパッケージ群へ更新する必要があったが、v11 への移行は DI 設計や Decorator などソースコードへの破壊的変更を伴うため、対応そのものを実施するかどうかの判断が必要になった。

対象となった主な脆弱性（例）：
- CVE-2025-27152（axios）
- CVE-2024-21538（cross-spawn）

##### 評価軸

| 評価軸 | 案A：Nest.js v11 へアップデート＋破壊的変更対応 | 案B：High ランクのため対応見送り | 案C：問題パッケージのみ個別更新・置換し Nest.js は据え置き |
|---|---|---|---|
| セキュリティリスク低減の確実性 | ◎ コアFWを含めて最新系にそろえるため、同系統の脆弱性を低減できる | △ 現状は稼働するが、既知脆弱性を残したままの運用になる  〇 対象パッケージの CVE は解消できるが、依存関係の取りこぼしリスクが残る |
| 影響範囲・工数 | △ 破壊的変更への対応や設計書修正が必要で工数は大きいが、一度で済む | ◎ 追加作業はほぼ発生せず、現状維持で運用できる | △ パッチや override 設計が複雑になり、検証工数もそれなりに発生する     |
| 保守性・将来のアップデートのしやすさ | ◎ 今後のアップデートも公式ドキュメントに沿って進めやすい | ✕ 古いバージョン前提のまま固定され、長期的に技術的負債になりやすい | △ 一時的には延命できるが、独自パッチが増えるほど将来の移行が難しくなる |
| 客先の期待・コンプライアンスとの整合 | ◎ 客先が High も含め即時対処を望んでおり、その期待に合致する | ✕ 客先の方針と反するため、説明しても受け入れられない可能性が高い | △ 一部対応としては説明可能だが、「抜本対応」としては弱く見えやすい |

##### 採否

- **案A：Nest.js v11 へアップデート＋破壊的変更への対応**  
  → **採用**

- **案B：High ランクのため対応を見送り、監視のみとする**  
  → **却下**（客先は High でも即時対応を求めていたため）

- **案C：問題パッケージのみ個別に更新・置換し、Nest.js は据え置く**  
  → **却下**

##### 却下理由

- **案B：High ランクのため対応を見送り、監視のみとする**  
  検出された脆弱性はいずれも High ランクであり、一般的な優先度としては「Critical より後回し」とする考え方もあるが、当案件の客先は High についても速やかな対応を求めていた。  
  既知の脆弱性を残したまま本番運用を続けることは、方針上も説明しにくく、インシデント発生時の説明責任の観点からも受け入れがたい。  
  以上から、案Bは客先のセキュリティポリシーと合致しないと判断し、採用しないことにした。

- **案C：問題パッケージのみ個別に更新・置換し、Nest.js は据え置く**  
  axios や cross-spawn など、指摘されたパッケージだけを個別に更新・置換することで、短期的には CVE を解消できる可能性はある。  
  しかし、依存関係の階層が複雑な中で一部だけを override すると、将来的なアップデートや不具合調査の際に状況が追いづらくなり、技術的負債を増やす結果になりやすい。  
  また、Nest.js 自体のメジャーバージョンが据え置きのままになるため、同様の対応を繰り返す必要が出てくる懸念もあった。  
  以上から、長期的な保守性の観点で得られるメリットが小さいと判断し、案Cは採用しないことにした。

##### 補足

本案件以前はビルド時に `npm install` を使用していたが、依存関係の再現性と長期的な保守性を高めるため、`package-lock.json` に基づき同一バージョンを復元できる `npm ci` を採用した。

#### ADR-02: Auth0の認証の過剰呼出によるレスポンス速度低下の対応方法判断

##### 背景

`axiosInstance.interceptors`内でAuth0を呼び出していた。
この処理はスクリプトであり、ページ読み込み・遷移のたびにAuth0認証を実行していた。
結果、レスポンス速度が平均1300ms余分にかかっていた。

読込キャッシュをオンにすることで改善できる見込みが立ったが、SPAである都合上なりすまし防止の観点で懸念があり、協力会社も交えて協議することになった。

##### 評価軸

各案について、次の観点で評価した。

- レスポンス改善効果（余分な待ち時間をどの程度削減できるか）
- セキュリティ・なりすまし耐性（認証まわりの安全性をどこまで保てるか）
- 実装・検証工数（変更量とテストの負荷）
- 影響範囲・既存設計との整合（既存フローへの影響の大きさ）

検討した案は以下のとおり。

- 案A：問題のスクリプト箇所から Auth0 認証呼び出しの 1 行を削除し、新しい認証フローを別途設計する
- 案B：Auth0 側のキャッシュモードを有効化し、同一セッション内の認証結果を再利用する
- 案C：Auth0 呼び出しを interceptor から切り離し、初回ロード時またはトークン有効期限切れ時のみ Auth0 認証を行うようにフローを再設計する

| 評価軸 | 案A：該当箇所から Auth0 呼び出しを削除 | 案B：Auth0 のキャッシュモードを有効化 | 案C：認証フローを再設計し、呼び出しタイミングを制御 |
|---|---|---|---|
| レスポンス改善効果 | 〇 現在の過剰呼び出しは解消できる可能性が高い | 〇 キャッシュ利用により余分な呼び出しを減らせる | 〇 トークン有効期限ベースにできれば効果は高い |
| セキュリティ・なりすまし耐性 | △ 新フロー設計を誤ると抜けや不整合のリスクがある | 〇 認証仕様はそのままで、キャッシュ利用可否のみを制御 | 〇 設計次第で高い水準を保てるが、検討とレビューが重くなる |
| 実装・検証工数 | △ 新しい認証ロジックの設計・実装・総合テストが必要 | 〇 設定変更と動作確認が中心で、比較的工数を抑えやすい | ✕ 認証全体の見直しが必要で、実装・テストともに工数が大きい |
| 影響範囲・既存設計との整合 | △ interceptor 前提の設計とぶつかる可能性がある | ◎ 既存フローを大きく変えずに対応できる | △ 設計としてはきれいだが、他箇所の修正も広範囲になりやすい |

##### 採否

- **案A：該当箇所から Auth0 呼び出しを削除し、新しい認証フローを設計する**  
  → **不採用**

- **案B：Auth0 のキャッシュモードを有効化する**  
  → **採用**  
  （協力会社による調査の結果、キャッシュを有効化してもセキュリティ上の問題はないと判断できたため）

- **案C：認証フローを再設計し、呼び出しタイミングを制御する**  
  → **不採用（中長期の改善案として別途検討）**

##### 却下理由

- **案A：該当箇所から Auth0 呼び出しを削除し、新しい認証フローを設計する**  
  現在の interceptor 前提の構成から認証呼び出しを外す場合、新しい認証タイミングと例外パターンを設計し直す必要があり、短期的な対応としては設計・テストの負荷が大きい。  
  認証を行う条件や責務の分担を誤ると、未認証でのアクセスや画面遷移時の不整合が発生するリスクもある。  
  今回は、キャッシュモードの有効化のみで性能とセキュリティの両立が確認できたため、より影響が小さい案Bを優先し、案Aは採用しないことにした。

- **案C：認証フローを再設計し、呼び出しタイミングを制御する**  
  トークン有効期限やセッション情報を基準に認証を行う設計は、中長期的には望ましいが、現状の構成からの変更範囲が大きく、実装・テストともに相応の工数が必要になる。  
  今回のインシデントは「過剰呼び出しによるレスポンス低下」が主な論点であり、キャッシュモードの活用だけで十分な改善が見込めることが分かった。  
  そのため、認証フロー全体の見直しは将来の改善テーマとして残しつつ、本対応としては採用しない判断とした。

### 振り返り

#### 技術的な学び

- クラウド環境（AWS）上でのアプリケーション運用や、ECS／Aurora／S3 を含む構成での障害対応を通じて、インフラ寄りの知識と対応力を身につけた。  
- CodeBuild／CodePipeline を用いたビルド自動化や Docker ベースの依存解決に携わる中で、Node.js 系プロジェクトにおける CI/CD 設計・運用の一連の流れを押さえられるようになった。

#### プロセス・コミュニケーションの学び

- 顧客との折衝や定例会議を通じて、SLA や責任範囲、対応優先度をすり合わせながら合意形成していくプロセスを経験した。  

#### 現状

- CI/CD パイプラインを AWS CodePipeline から GitHub Actions へ移行する方針を検討中。  
- Prisma バージョンアップ（v6 → v7）に伴う破壊的変更への対応方法を整理中。  
- リグレッションテストを従来の手動実行から、Playwright を用いた自動実行へ切り替えることを検討中。